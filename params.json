{"name":"Vice","tagline":"Vice is a small web framework for easy dispatching actions for a given URL","body":"# Vice\r\n\r\nVice is a small web framework for easy dispatching actions for a given URL.\r\n\r\nIt uses some nifty tricks to make sure you don't have to;\r\n* Easy restriction of HTTP-methods\r\n* Simple AJAX response\r\n* Arguments filled based on their name, for easy access\r\n* Named parameters in the URI\r\n* Powerfull filters\r\n\r\n## Requirements\r\n* PHP >= 5.4\r\n\r\n## Example application\r\nYou can check the `example`-directory in this repository to see it all in action. You can run the example with PHPs builtin server:\r\n\r\n\tphp -S localhost:9000 -t example/\r\n\r\nNow open [http://localhost:9000](http://localhost:9000) in your browser to see the example.\r\n\r\n## Examples\r\n\r\n### Basic example\r\n```php\r\n$app = new Vice;\r\n$app->route('/', function()\r\n{\r\n    echo 'Hello world!';\r\n});\r\n$app_>run();\r\n```\r\n\r\n### JSON Helper\r\n```php\r\n$app = new Vice;\r\n\r\n// route that only responds to ajax-post requests\r\n$app->post('/users', 'is:ajax', function($json)\r\n{\r\n    // builtin helper, sets a header, encodes it, and dies\r\n    $json([\r\n        [\r\n            'name' => 'Pizza kat',\r\n        ]\r\n    ]);\r\n});\r\n```\r\n\r\n### Global store\r\n```php\r\n$app = new Vice('/', [\r\n    'db' => new Database, // some database connection\r\n]);\r\n\r\n$app->get('/', function($db)\r\n{\r\n    // $db is the one that you put in the store\r\n});\r\n```\r\n\r\n### Advanced filters\r\n```php\r\n$app = new Vice;\r\n$app->registerFilter('is:logged', function()\r\n{\r\n    if (/* some login check */)\r\n    {\r\n        return [\r\n            'name' => 'Flavored mushrooms',\r\n        ];\r\n    }\r\n    else\r\n    {\r\n        return false;\r\n    }\r\n});\r\n\r\n$app->get('/admin', 'is:logged', function($isLogged)\r\n{\r\n    // $isLogged would contain the result of the filter,\r\n\t// if the filter fails, then this function is never called\r\n\techo 'Hello ' . $isLogged['name'] . '!';\r\n});\r\n```\r\n\r\n### Subapps\r\n```php\r\n$app = new Vice('/', [ 'db' => new Database ]);\r\n$users = new Vice;\r\n\r\n$users->get('<id>', function($json, $db, $id, $param)\r\n{\r\n    // $param('id') === $id\r\n    $json($db->users->get($id));\r\n});\r\n\r\n// users subapp is available at /users and only for ajax-get-requests\r\n// this would make the route /users/1 available\r\n$app->get('users', 'is:ajax', $users);\r\n```\r\n_Subapps share the filters and store from their parent, but not the other way around._\r\n\r\n### Multiple filters chained\r\n```php\r\n$app = new Vice('/', [ 'currentUser' => 1, 'db' => new Database ]);\r\n\r\n$app->registerFilter('is:logged', function($db, $currentUser)\r\n{\r\n    // check for existince of current user and return it\r\n    return $db->users->get($currentUser) ?: false;\r\n});\r\n\r\n$app->registerFilter('is:admin', function($isLogged)\r\n{\r\n    return $isLogged['admin'] === true;\r\n});\r\n\r\n$app->route('admin', 'is:logged is:admin', function($isLogged)\r\n{\r\n    echo 'Hello ' . $isLogged['name'] . ', you are an admin!';\r\n});\r\n```\r\n\r\n## Builtin filters\r\n* GET-request\r\n* POST-request\r\n* PUT-request\r\n* DELETE-request\r\n* AJAX-request\r\n\r\n_(by `$app->get(..)` or as a filter `$app->route('/', 'is:get')` (same for all others)_\r\n\r\n## Builtin named arguments\r\n* `$post` -> `function($key, $default = null)`-wrapper for `$_POST`\r\n* `$get` -> `function($key, $default = null)`-wrapper for `$_GET`\r\n* `$param` -> `function($key, $default = null)`-wrapper for the parameters in the URI\r\n* `$server` -> `function($key, $default = null)`-wrapper for `$_SERVER`\r\n* `$store` -> `function($key, $default = null)`-wrapper for the global store\r\n* `$filter` -> `function($key, $default = null)`-wrapper for passed filter results\r\n* `$ajax` -> `boolean` that tells you if the request is an AJAX one\r\n* `$json` -> `function($data)` JSON helper\r\n* Keys from the `params`, `store`, `filterResults` (in that order)\r\n\r\n## Some technical insights\r\n* Every route is compiled to a regex, which is then matched against the current URI. When a match is found all the defined filters for that route are tested. If it is still a match, then we run the corresponding action. When the action is an app itself, the whole process is ran again, but without the prefix we already matched. After some looping something probably happened and we're done.\r\n* `Reflection` is used to determine the value of the arguments\r\n* It's a single class, everything else is a function\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}